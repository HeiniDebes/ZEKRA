package xjsnark.zekra;

/*Generated by MPS */

import backend.structure.CircuitGenerator;
import backend.config.Config;
import backend.eval.SampleRun;
import java.io.BufferedReader;
import java.io.FileReader;
import java.math.BigInteger;
import backend.auxTypes.FieldElement;
import backend.auxTypes.UnsignedInteger;
import backend.auxTypes.SmartMemory;
import util.Util;
import backend.eval.Instruction;
import backend.eval.CircuitEvaluator;
import java.math.BigDecimal;
import java.math.RoundingMode;
import backend.auxTypes.Bit;
import backend.auxTypes.ConditionalScopeTracker;

public class zekra extends CircuitGenerator {



  public static void main(String[] args) {
    Config.outputVerbose = true;
    Config.inputVerbose = false;
    Config.debugVerbose = true;
    Config.writeCircuits = true;
    Config.outputFilesPath = "";
    new zekra();
  }

  public zekra() {
    super("zekra");
    __generateCircuit();
    this.__evaluateSampleRun(new SampleRun("Sample_Run1", true) {
      public void pre() {
        String line;
        int i = 0;
        try {
          BufferedReader br = new BufferedReader(new FileReader(inputPathPrefix + "in_encoded_adjlist"));
          while ((line = br.readLine()) != null) {
            ADJLIST[i].mapValue(new BigInteger(line, 10), CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());
            i = i + 1;
          }

          br = new BufferedReader(new FileReader(inputPathPrefix + "in_translator"));
          i = 0;
          while ((line = br.readLine()) != null) {
            TRANSLATOR[i].mapValue(new BigInteger(line, 10), CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());
            i = i + 1;
          }

          br = new BufferedReader(new FileReader(inputPathPrefix + "in_recorded_path"));
          i = 0;
          while ((line = br.readLine()) != null) {
            String[] transition = line.split(" ");
            BigInteger jmpkind = new BigInteger(transition[0], 10);
            BigInteger destAddr = new BigInteger(transition[1], 10);
            BigInteger retAddr = new BigInteger(transition[2], 10);
            EXECUTION_PATH[i][0].mapValue(jmpkind, CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());
            EXECUTION_PATH[i][1].mapValue(destAddr, CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());
            EXECUTION_PATH[i][2].mapValue(retAddr, CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());
            i = i + 1;
          }

          br = new BufferedReader(new FileReader(inputPathPrefix + "in_numified_path"));
          i = 0;
          while ((line = br.readLine()) != null) {
            String[] transition = line.split(" ");
            BigInteger destLabel = new BigInteger(transition[0], 10);
            BigInteger retLabel = new BigInteger(transition[1], 10);
            NUMIFIED_EXECUTION_PATH[i][0].mapValue(destLabel, CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());
            NUMIFIED_EXECUTION_PATH[i][1].mapValue(retLabel, CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());
            dest[i].mapValue(destLabel, CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());
            i = i + 1;
          }

          br = new BufferedReader(new FileReader(inputPathPrefix + "in_initial_node"));
          initialNode.mapValue(new BigInteger(br.readLine(), 10), CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());
          br = new BufferedReader(new FileReader(inputPathPrefix + "in_final_node"));
          finalNode.mapValue(new BigInteger(br.readLine(), 10), CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());
          br = new BufferedReader(new FileReader(inputPathPrefix + "in_nonce_verifier"));
          nonceVerifier.mapValue(new BigInteger(br.readLine(), 10), CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());
          br = new BufferedReader(new FileReader(inputPathPrefix + "in_nonce_path"));
          noncePath.mapValue(new BigInteger(br.readLine(), 10), CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());
          br = new BufferedReader(new FileReader(inputPathPrefix + "in_nonce_adjlist"));
          nonceAdjlist.mapValue(new BigInteger(br.readLine(), 10), CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());
          br = new BufferedReader(new FileReader(inputPathPrefix + "in_nonce_translator"));
          nonceTranslator.mapValue(new BigInteger(br.readLine(), 10), CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());
          br = new BufferedReader(new FileReader(inputPathPrefix + "in_encoded_adjlist_digest"));
          adjListDigest.mapValue(new BigInteger(br.readLine(), 10), CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());
          br = new BufferedReader(new FileReader(inputPathPrefix + "in_recorded_path_digest"));
          executionPathDigest.mapValue(new BigInteger(br.readLine(), 10), CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());
          br = new BufferedReader(new FileReader(inputPathPrefix + "in_translator_digest"));
          translatorDigest.mapValue(new BigInteger(br.readLine(), 10), CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());

          // create hints for verifying that the translation was done correctly inside the circuit 
          for (int j = 0; j < EXECUTION_PATH_SIZE; j++) {
            // if destination targets the empty move 
            if (EXECUTION_PATH[j][1].getValueFromEvaluator(CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator()).equals(BigInteger.valueOf(EMPTY_DEST_ADDR))) {
              TRANSLATION_HINTS[j][0].mapValue(BigInteger.valueOf(ADJLIST_SIZE), CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());
            } else {
              for (int k = 0; k < TRANSLATOR.length; k++) {
                if (TRANSLATOR[k].getValueFromEvaluator(CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator()).equals(EXECUTION_PATH[j][1].getValueFromEvaluator(CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator()))) {
                  TRANSLATION_HINTS[j][0].mapValue(BigInteger.valueOf(k), CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());
                  break;
                }
              }
            }
            // if return targets the empty move 
            if (EXECUTION_PATH[j][2].getValueFromEvaluator(CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator()).equals(BigInteger.valueOf(EMPTY_DEST_ADDR))) {
              TRANSLATION_HINTS[j][1].mapValue(BigInteger.valueOf(ADJLIST_SIZE), CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());
            } else {
              for (int k = 0; k < TRANSLATOR.length; k++) {
                if (TRANSLATOR[k].getValueFromEvaluator(CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator()).equals(EXECUTION_PATH[j][2].getValueFromEvaluator(CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator()))) {
                  TRANSLATION_HINTS[j][1].mapValue(BigInteger.valueOf(k), CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());
                  break;
                }
              }
            }
          }
        } catch (Exception ex) {
          System.out.println(ex.getMessage().toString());
        }
      }
      public void post() {
      }

    });

  }



  public void __init() {
    inputPathPrefix = "";
    EMPTY_DEST_ADDR = 0;
    SHADOWSTACK = (FieldElement[]) FieldElement.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{SHADOWSTACK_DEPTH}, new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"));
    ADJLIST = (FieldElement[]) FieldElement.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{ADJLIST_SIZE}, new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"));
    EXECUTION_PATH = (FieldElement[][]) FieldElement.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{EXECUTION_PATH_SIZE, 3}, new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"));
    NUMIFIED_EXECUTION_PATH = (FieldElement[][]) FieldElement.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{EXECUTION_PATH_SIZE, 2}, new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"));
    TRANSLATOR = (FieldElement[]) FieldElement.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{ADJLIST_SIZE + 1}, new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"));
    TRANSLATION_HINTS = (UnsignedInteger[][]) UnsignedInteger.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{EXECUTION_PATH_SIZE, 2}, 11);
    adjListDigest = new FieldElement(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), new BigInteger("0"));
    executionPathDigest = new FieldElement(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), new BigInteger("0"));
    translatorDigest = new FieldElement(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), new BigInteger("0"));
    shadowStackTop = new UnsignedInteger(4, new BigInteger("0"));
    initialNode = new UnsignedInteger(11, new BigInteger("0"));
    finalNode = new UnsignedInteger(11, new BigInteger("0"));
    nonceVerifier = new FieldElement(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), new BigInteger("0"));
    noncePath = new FieldElement(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), new BigInteger("0"));
    nonceAdjlist = new FieldElement(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), new BigInteger("0"));
    nonceTranslator = new FieldElement(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), new BigInteger("0"));
    eAndR1 = (UnsignedInteger[][]) UnsignedInteger.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{EXECUTION_PATH_SIZE, 2}, 8);
    neighborEq = (FieldElement[][]) FieldElement.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{EXECUTION_PATH_SIZE, ADJLIST_LEVELS * 2}, new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"));
    neighborExistsProof = (FieldElement[][]) FieldElement.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{EXECUTION_PATH_SIZE, 5}, new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"));
    dest = (UnsignedInteger[]) UnsignedInteger.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{EXECUTION_PATH_SIZE}, 11);
  }

  public String inputPathPrefix;
  private int EMPTY_DEST_ADDR;
  private FieldElement[] SHADOWSTACK;
  private FieldElement[] ADJLIST;
  private FieldElement[][] EXECUTION_PATH;
  private FieldElement[][] NUMIFIED_EXECUTION_PATH;
  private FieldElement[] TRANSLATOR;
  private UnsignedInteger[][] TRANSLATION_HINTS;
  private FieldElement adjListDigest;
  private FieldElement executionPathDigest;
  private FieldElement translatorDigest;
  private UnsignedInteger shadowStackTop;
  private UnsignedInteger initialNode;
  private UnsignedInteger finalNode;
  private FieldElement nonceVerifier;
  private FieldElement noncePath;
  private FieldElement nonceAdjlist;
  private FieldElement nonceTranslator;
  private UnsignedInteger[][] eAndR1;
  private FieldElement[][] neighborEq;
  private FieldElement[][] neighborExistsProof;
  private UnsignedInteger[] dest;
  private SmartMemory<FieldElement> adjListMem;
  private SmartMemory<FieldElement> shadowStackMem;
  private SmartMemory<FieldElement> translatorMem;

  private static int P_BITWIDTH = 254;
  private static int JUMPKIND_BITWIDTH = 2;
  private static int BUCKET_BITWIDTH = 7;
  private static int ADDR_BITWIDTH = 40;
  private static int ADJLIST_SIZE = 100;
  private static int ADJLIST_LEVELS = 10;
  private static int EXECUTION_PATH_SIZE = 30;
  private static int SHADOWSTACK_DEPTH = 15;
  @Override
  public void __defineInputs() {
    super.__defineInputs();
    initialNode = UnsignedInteger.createInput(this, 11);
    finalNode = UnsignedInteger.createInput(this, 11);
    nonceVerifier = FieldElement.createInput(this, new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"));
    adjListDigest = FieldElement.createInput(this, new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"));
    executionPathDigest = FieldElement.createInput(this, new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"));
    translatorDigest = FieldElement.createInput(this, new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"));















  }
  @Override
  public void __defineVerifiedWitnesses() {
    super.__defineVerifiedWitnesses();

    noncePath = FieldElement.createVerifiedWitness(this, new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"));
    nonceAdjlist = FieldElement.createVerifiedWitness(this, new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"));
    nonceTranslator = FieldElement.createVerifiedWitness(this, new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"));




    EXECUTION_PATH = (FieldElement[][]) FieldElement.createVerifiedWitnessArray(CircuitGenerator.__getActiveCircuitGenerator(), Util.getArrayDimensions(EXECUTION_PATH), new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"));
    ADJLIST = (FieldElement[]) FieldElement.createVerifiedWitnessArray(CircuitGenerator.__getActiveCircuitGenerator(), Util.getArrayDimensions(ADJLIST), new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"));
    neighborEq = (FieldElement[][]) FieldElement.createVerifiedWitnessArray(CircuitGenerator.__getActiveCircuitGenerator(), Util.getArrayDimensions(neighborEq), new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"));
    neighborExistsProof = (FieldElement[][]) FieldElement.createVerifiedWitnessArray(CircuitGenerator.__getActiveCircuitGenerator(), Util.getArrayDimensions(neighborExistsProof), new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"));
    NUMIFIED_EXECUTION_PATH = (FieldElement[][]) FieldElement.createVerifiedWitnessArray(CircuitGenerator.__getActiveCircuitGenerator(), Util.getArrayDimensions(NUMIFIED_EXECUTION_PATH), new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"));
    TRANSLATOR = (FieldElement[]) FieldElement.createVerifiedWitnessArray(CircuitGenerator.__getActiveCircuitGenerator(), Util.getArrayDimensions(TRANSLATOR), new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"));














  }
  @Override
  public void __defineWitnesses() {
    super.__defineWitnesses();





    eAndR1 = (UnsignedInteger[][]) UnsignedInteger.createWitnessArray(CircuitGenerator.__getActiveCircuitGenerator(), Util.getArrayDimensions(eAndR1), 8);
    dest = (UnsignedInteger[]) UnsignedInteger.createWitnessArray(CircuitGenerator.__getActiveCircuitGenerator(), Util.getArrayDimensions(dest), 11);
    TRANSLATION_HINTS = (UnsignedInteger[][]) UnsignedInteger.createWitnessArray(CircuitGenerator.__getActiveCircuitGenerator(), Util.getArrayDimensions(TRANSLATION_HINTS), 11);












  }
  public void outsource() {
    if ((BUCKET_BITWIDTH + 8) * ADJLIST_LEVELS >= P_BITWIDTH) {
      throw new IllegalArgumentException("(BUCKET_BITWIDTH+8)*ADJ_LIST_LEVELS cannot exceed p's bitwidth");
    }

    // code executed outside the circuit 
    CircuitGenerator.__getActiveCircuitGenerator().__specifyProverWitnessComputation(new Instruction() {
      public void evaluate(CircuitEvaluator p0) {
        BigInteger state = initialNode.getValueFromEvaluator(CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());
        for (int i = 0; i < EXECUTION_PATH_SIZE; i++) {
          BigInteger[] quotients = new BigInteger[ADJLIST_LEVELS];
          BigInteger[] remainders = new BigInteger[ADJLIST_LEVELS];
          BigInteger[] neighbourExistsProofVals = new BigInteger[5];
          BigInteger[] eAndR1Vals = new BigInteger[2];

          for (int j = 0; j < ADJLIST_LEVELS; j++) {
            quotients[j] = BigInteger.ZERO;
            remainders[j] = BigInteger.ZERO;
          }
          for (int j = 0; j < neighbourExistsProofVals.length; j++) {
            neighbourExistsProofVals[j] = BigInteger.ZERO;
          }
          for (int j = 0; j < eAndR1Vals.length; j++) {
            eAndR1Vals[j] = BigInteger.ZERO;
          }

          BigInteger destNode = NUMIFIED_EXECUTION_PATH[i][0].getValueFromEvaluator(CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());
          BigInteger pos = destNode.mod(BigInteger.valueOf(8));
          BigInteger bucket = destNode.divide(BigInteger.valueOf(8));

          if (!(destNode.equals(BigInteger.valueOf(ADJLIST_SIZE)))) {
            BigInteger currNodeAdjList = ADJLIST[state.intValue()].getValueFromEvaluator(CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());

            for (int j = 0, k = 0; j < ADJLIST_LEVELS; j++, k += (BUCKET_BITWIDTH + 8)) {
              quotients[j] = currNodeAdjList.shiftRight(k).and(BigInteger.valueOf(2).pow(BUCKET_BITWIDTH).subtract(BigInteger.valueOf(1)));
              remainders[j] = currNodeAdjList.shiftRight(k + BUCKET_BITWIDTH).and(BigInteger.valueOf(255));

              // if the destination node exists at this level of the adjacency list 
              if (bucket.equals(quotients[j]) && remainders[j].testBit(pos.intValue())) {
                // e 
                neighbourExistsProofVals[0] = BigInteger.valueOf(2).pow(pos.intValue());
                // q1 
                neighbourExistsProofVals[1] = new BigDecimal(remainders[j]).divide(new BigDecimal(neighbourExistsProofVals[0]), RoundingMode.FLOOR).toBigInteger();
                // r1 
                neighbourExistsProofVals[2] = remainders[j].mod(neighbourExistsProofVals[0]);
                // q2 
                neighbourExistsProofVals[3] = neighbourExistsProofVals[1].divide(BigInteger.valueOf(2));
                // r2 
                neighbourExistsProofVals[4] = neighbourExistsProofVals[1].mod(BigInteger.valueOf(2));

                eAndR1Vals[0] = neighbourExistsProofVals[0];
                eAndR1Vals[1] = neighbourExistsProofVals[2];
              }
            }
          }

          for (int j = 0, k = 0; j < ADJLIST_LEVELS; j++, k += 2) {
            neighborEq[i][k].mapValue(quotients[j], CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());
            neighborEq[i][k + 1].mapValue(remainders[j], CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());
          }
          for (int j = 0; j < neighbourExistsProofVals.length; j++) {
            neighborExistsProof[i][j].mapValue(neighbourExistsProofVals[j], CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());
          }
          for (int j = 0; j < eAndR1Vals.length; j++) {
            eAndR1[i][j].mapValue(eAndR1Vals[j], CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());
          }

          state = destNode;
        }
      }
    });


    // ///////////////////////////////////////////////////// 
    // the remaining code is compiled into the ZEKRA circuit 

    adjListMem = new SmartMemory(ADJLIST, FieldElement.__getClassRef(), new Object[]{"21888242871839275222246405745257275088548364400416034343698204186575808495617"});
    shadowStackMem = new SmartMemory(SHADOWSTACK, FieldElement.__getClassRef(), new Object[]{"21888242871839275222246405745257275088548364400416034343698204186575808495617"});
    translatorMem = new SmartMemory(TRANSLATOR, FieldElement.__getClassRef(), new Object[]{"21888242871839275222246405745257275088548364400416034343698204186575808495617"});


    // //////////////////////////// 
    // Begin by verifying the translator, execution path, and adjacency list 

    // first verify authenticity of adjacency list 
    int neighbors_bitwidth = ADJLIST_LEVELS * (BUCKET_BITWIDTH + 8);
    FieldElement[] adjlist_compressed = compress(ADJLIST, neighbors_bitwidth);
    FieldElement[] adjlist_padded = make_multiple_of(adjlist_compressed, 8, 1);
    adjlist_padded[adjlist_padded.length - 1].assign(nonceAdjlist);
    FieldElement tmp_adjlist_digest = hash(adjlist_padded).copy();
    CircuitGenerator.__getActiveCircuitGenerator().__addDebugInstruction(tmp_adjlist_digest, "computed adjlist digest");
    CircuitGenerator.__getActiveCircuitGenerator().__addDebugInstruction(adjListDigest, "input adjlist digest");
    tmp_adjlist_digest.forceEqual(adjListDigest);

    // then verify authenticity of execution path 
    int transition_bitwidth = JUMPKIND_BITWIDTH + ADDR_BITWIDTH * 2;
    FieldElement[] path_compressed = compress(EXECUTION_PATH, transition_bitwidth);
    FieldElement[] path_padded = make_multiple_of(path_compressed, 8, 2);
    path_padded[path_padded.length - 2].assign(nonceVerifier);
    path_padded[path_padded.length - 1].assign(noncePath);
    FieldElement tmp_path_digest = hash(path_padded).copy();
    CircuitGenerator.__getActiveCircuitGenerator().__addDebugInstruction(tmp_path_digest, "computed path digest");
    CircuitGenerator.__getActiveCircuitGenerator().__addDebugInstruction(executionPathDigest, "input path digest");
    tmp_path_digest.forceEqual(executionPathDigest);

    // then verify authenticity of translator 
    FieldElement[] translator_compressed = compress(TRANSLATOR, ADDR_BITWIDTH);
    FieldElement[] translator_padded = make_multiple_of(translator_compressed, 8, 1);
    translator_padded[translator_padded.length - 1].assign(nonceTranslator);
    FieldElement tmp_translator_digest = hash(translator_padded).copy();
    CircuitGenerator.__getActiveCircuitGenerator().__addDebugInstruction(tmp_translator_digest, "computed translator digest");
    CircuitGenerator.__getActiveCircuitGenerator().__addDebugInstruction(translatorDigest, "input translator digest");
    tmp_translator_digest.forceEqual(translatorDigest);


    // //////////////////////////// 
    // Then verify that the translation of the raw execution path to the numified execution path was done correctly 
    // NOTE: this component prevents feeding isomorphic graphs by including the translation in the proof 
    for (int i = 0; i < EXECUTION_PATH_SIZE; i++) {
      translatorMem.read(TRANSLATION_HINTS[i][0]).forceEqual(EXECUTION_PATH[i][1]);
      translatorMem.read(TRANSLATION_HINTS[i][1]).forceEqual(EXECUTION_PATH[i][2]);
      FieldElement.instantiateFrom(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), TRANSLATION_HINTS[i][0]).forceEqual(NUMIFIED_EXECUTION_PATH[i][0]);
      FieldElement.instantiateFrom(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), TRANSLATION_HINTS[i][1]).forceEqual(NUMIFIED_EXECUTION_PATH[i][1]);
    }


    // //////////////////////////// 
    // Then proceed to verify forward and back edges using the numified execution path 

    // start from the initial node 
    UnsignedInteger state = initialNode.copy(11);

    // traverse the execution path 
    for (int i = 0; i < EXECUTION_PATH_SIZE; i++) {

      // jmpkind: 00 (jmp), 01 (call), 10 (ret), 11 (empty) 
      FieldElement jmpkind = EXECUTION_PATH[i][0].copy();
      FieldElement destNode = NUMIFIED_EXECUTION_PATH[i][0].copy();
      FieldElement retNode = NUMIFIED_EXECUTION_PATH[i][1].copy();

      // verify forward edges (ignore empty moves to facilitate dynamic path lengths) 
      {
        Bit bit_h0jc0qc = jmpkind.isNotEqualTo(FieldElement.instantiateFrom(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), 3)).copy();
        boolean c_h0jc0qc = CircuitGenerator.__getActiveCircuitGenerator().__checkConstantState(bit_h0jc0qc);
        if (c_h0jc0qc) {
          if (bit_h0jc0qc.getConstantValue()) {

            UnsignedInteger uintDestNode = dest[i].copy(11);
            destNode.forceEqual(FieldElement.instantiateFrom(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), uintDestNode));
            UnsignedInteger bucket = uintDestNode.div(UnsignedInteger.instantiateFrom(4, 8)).copy(11);
            UnsignedInteger pos = UnsignedInteger.instantiateFrom(3, uintDestNode.mod(UnsignedInteger.instantiateFrom(4, 8))).copy(3);

            // retrieve the neighbour list of the current node 
            FieldElement currNodeNeighbors = adjListMem.read(state);

            // v.t. neighbor equation equals the current node's neighbors 
            FieldElement neighborEqProd = new FieldElement(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), new BigInteger("0"));
            for (int j = 0, k = 0; j < ADJLIST_LEVELS * 2; j += 2, k += (BUCKET_BITWIDTH + 8)) {
              neighborEqProd.assign(neighborEqProd.add(neighborEq[i][j].mul(FieldElement.instantiateFrom(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), BigInteger.valueOf(2).pow(k)))));
              neighborEqProd.assign(neighborEqProd.add(neighborEq[i][j + 1].mul(FieldElement.instantiateFrom(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), BigInteger.valueOf(2).pow(k + BUCKET_BITWIDTH)))));
            }
            neighborEqProd.forceEqual(currNodeNeighbors);

            // v.t. h * 2 + k = f 
            neighborExistsProof[i][3].mul(FieldElement.instantiateFrom(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), 2)).add(neighborExistsProof[i][4]).forceEqual(neighborExistsProof[i][1]);
            // v.t. bit at pos is set 
            neighborExistsProof[i][4].forceEqual(FieldElement.instantiateFrom(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), 1));

            // v.t. e=2**(destNode%8) 
            // efficient linear search to find if there is some j s.t. e = 2**j AND pos=j, where pos is computed inside the circuit as pos=destNode%8 
            FieldElement validExp = FieldElement.instantiateFrom(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), 1).copy();
            for (double j = 0, k = 1; j < 8; j++, k = Math.pow(2, j)) {
              validExp.assign(validExp.mul(((FieldElement.instantiateFrom(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), pos).subtract(FieldElement.instantiateFrom(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), new Double(j).intValue()))).add((neighborExistsProof[i][0].subtract(FieldElement.instantiateFrom(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), new Double(k).intValue())))))));
            }
            validExp.forceEqual(FieldElement.instantiateFrom(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), 0));

            // v.t. g < e 
            FieldElement.instantiateFrom(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), eAndR1[i][0]).forceEqual(neighborExistsProof[i][0]);
            FieldElement.instantiateFrom(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), eAndR1[i][1]).forceEqual(neighborExistsProof[i][2]);
            CircuitGenerator.__getActiveCircuitGenerator().__addOneAssertion(eAndR1[i][0].isGreaterThan(eAndR1[i][1]).getWire());

            // v.t. destNode exists at some level in the adjacency list 
            FieldElement destNodeExists = FieldElement.instantiateFrom(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), 1).copy();
            for (int j = 0; j < ADJLIST_LEVELS * 2; j += 2) {
              // v.t. f * e + g = rems 
              FieldElement remaindersMatch = neighborExistsProof[i][1].mul(neighborExistsProof[i][0]).add(neighborExistsProof[i][2]).subtract(neighborEq[i][j + 1]).copy();
              FieldElement bucketMatch = FieldElement.instantiateFrom(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), bucket).subtract(neighborEq[i][j]).copy();
              // v.t. remaindersMatch and bucketMatch 
              destNodeExists.assign(destNodeExists.mul((remaindersMatch.add(bucketMatch))));
            }
            destNodeExists.forceEqual(FieldElement.instantiateFrom(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), 0));

            // update position in the CFG 
            state.assign(uintDestNode, 11);
          } else {

          }
        } else {
          ConditionalScopeTracker.pushMain();
          ConditionalScopeTracker.push(bit_h0jc0qc);

          UnsignedInteger uintDestNode = dest[i].copy(11);
          destNode.forceEqual(FieldElement.instantiateFrom(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), uintDestNode));
          UnsignedInteger bucket = uintDestNode.div(UnsignedInteger.instantiateFrom(4, 8)).copy(11);
          UnsignedInteger pos = UnsignedInteger.instantiateFrom(3, uintDestNode.mod(UnsignedInteger.instantiateFrom(4, 8))).copy(3);

          // retrieve the neighbour list of the current node 
          FieldElement currNodeNeighbors = adjListMem.read(state);

          // v.t. neighbor equation equals the current node's neighbors 
          FieldElement neighborEqProd = new FieldElement(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), new BigInteger("0"));
          for (int j = 0, k = 0; j < ADJLIST_LEVELS * 2; j += 2, k += (BUCKET_BITWIDTH + 8)) {
            neighborEqProd.assign(neighborEqProd.add(neighborEq[i][j].mul(FieldElement.instantiateFrom(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), BigInteger.valueOf(2).pow(k)))));
            neighborEqProd.assign(neighborEqProd.add(neighborEq[i][j + 1].mul(FieldElement.instantiateFrom(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), BigInteger.valueOf(2).pow(k + BUCKET_BITWIDTH)))));
          }
          neighborEqProd.forceEqual(currNodeNeighbors);

          // v.t. h * 2 + k = f 
          neighborExistsProof[i][3].mul(FieldElement.instantiateFrom(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), 2)).add(neighborExistsProof[i][4]).forceEqual(neighborExistsProof[i][1]);
          // v.t. bit at pos is set 
          neighborExistsProof[i][4].forceEqual(FieldElement.instantiateFrom(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), 1));

          // v.t. e=2**(destNode%8) 
          // efficient linear search to find if there is some j s.t. e = 2**j AND pos=j, where pos is computed inside the circuit as pos=destNode%8 
          FieldElement validExp = FieldElement.instantiateFrom(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), 1).copy();
          for (double j = 0, k = 1; j < 8; j++, k = Math.pow(2, j)) {
            validExp.assign(validExp.mul(((FieldElement.instantiateFrom(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), pos).subtract(FieldElement.instantiateFrom(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), new Double(j).intValue()))).add((neighborExistsProof[i][0].subtract(FieldElement.instantiateFrom(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), new Double(k).intValue())))))));
          }
          validExp.forceEqual(FieldElement.instantiateFrom(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), 0));

          // v.t. g < e 
          FieldElement.instantiateFrom(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), eAndR1[i][0]).forceEqual(neighborExistsProof[i][0]);
          FieldElement.instantiateFrom(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), eAndR1[i][1]).forceEqual(neighborExistsProof[i][2]);
          CircuitGenerator.__getActiveCircuitGenerator().__addOneAssertion(eAndR1[i][0].isGreaterThan(eAndR1[i][1]).getWire());

          // v.t. destNode exists at some level in the adjacency list 
          FieldElement destNodeExists = FieldElement.instantiateFrom(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), 1).copy();
          for (int j = 0; j < ADJLIST_LEVELS * 2; j += 2) {
            // v.t. f * e + g = rems 
            FieldElement remaindersMatch = neighborExistsProof[i][1].mul(neighborExistsProof[i][0]).add(neighborExistsProof[i][2]).subtract(neighborEq[i][j + 1]).copy();
            FieldElement bucketMatch = FieldElement.instantiateFrom(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), bucket).subtract(neighborEq[i][j]).copy();
            // v.t. remaindersMatch and bucketMatch 
            destNodeExists.assign(destNodeExists.mul((remaindersMatch.add(bucketMatch))));
          }
          destNodeExists.forceEqual(FieldElement.instantiateFrom(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), 0));

          // update position in the CFG 
          state.assign(uintDestNode, 11);

          ConditionalScopeTracker.pop();

          ConditionalScopeTracker.push(new Bit(true));

          ConditionalScopeTracker.pop();
          ConditionalScopeTracker.popMain();
        }

      }

      // verify back edges using shadow stack (push return address on stack if call, check if destination address matches top value on stack if ret) 
      {
        Bit bit_k0jc0qc = jmpkind.isEqualTo(FieldElement.instantiateFrom(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), 1)).copy();
        boolean c_k0jc0qc = CircuitGenerator.__getActiveCircuitGenerator().__checkConstantState(bit_k0jc0qc);
        if (c_k0jc0qc) {
          if (bit_k0jc0qc.getConstantValue()) {
            // add caller return address to shadow stack 
            push(retNode.copy());
          } else {
            {
              Bit bit_a0a0a0a2a01a16a86 = jmpkind.isEqualTo(FieldElement.instantiateFrom(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), 2)).copy();
              boolean c_a0a0a0a2a01a16a86 = CircuitGenerator.__getActiveCircuitGenerator().__checkConstantState(bit_a0a0a0a2a01a16a86);
              if (c_a0a0a0a2a01a16a86) {
                if (bit_a0a0a0a2a01a16a86.getConstantValue()) {
                  // verify return address integrity 
                  FieldElement shadowAddr = pop().copy();
                  shadowAddr.forceEqual(destNode);
                } else {

                }
              } else {
                ConditionalScopeTracker.pushMain();
                ConditionalScopeTracker.push(bit_a0a0a0a2a01a16a86);
                // verify return address integrity 
                FieldElement shadowAddr = pop().copy();
                shadowAddr.forceEqual(destNode);

                ConditionalScopeTracker.pop();

                ConditionalScopeTracker.push(new Bit(true));

                ConditionalScopeTracker.pop();
                ConditionalScopeTracker.popMain();
              }

            }

          }
        } else {
          ConditionalScopeTracker.pushMain();
          ConditionalScopeTracker.push(bit_k0jc0qc);
          // add caller return address to shadow stack 
          push(retNode.copy());

          ConditionalScopeTracker.pop();

          ConditionalScopeTracker.push(new Bit(true));

          {
            Bit bit_a0a01a16a86_0 = jmpkind.isEqualTo(FieldElement.instantiateFrom(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), 2)).copy();
            boolean c_a0a01a16a86_0 = CircuitGenerator.__getActiveCircuitGenerator().__checkConstantState(bit_a0a01a16a86_0);
            if (c_a0a01a16a86_0) {
              if (bit_a0a01a16a86_0.getConstantValue()) {
                // verify return address integrity 
                FieldElement shadowAddr = pop().copy();
                shadowAddr.forceEqual(destNode);
              } else {

              }
            } else {
              ConditionalScopeTracker.pushMain();
              ConditionalScopeTracker.push(bit_a0a01a16a86_0);
              // verify return address integrity 
              FieldElement shadowAddr = pop().copy();
              shadowAddr.forceEqual(destNode);

              ConditionalScopeTracker.pop();

              ConditionalScopeTracker.push(new Bit(true));

              ConditionalScopeTracker.pop();
              ConditionalScopeTracker.popMain();
            }

          }
          ConditionalScopeTracker.pop();
          ConditionalScopeTracker.popMain();
        }

      }
    }

    state.forceEqual(finalNode);
  }
  private FieldElement[] compress(FieldElement[] tmp_list, int elem_bitwidth) {
    if (elem_bitwidth >= P_BITWIDTH) {
      throw new IllegalArgumentException("elem_bitwidth cannot exceed p's bitwidth");
    }

    int elems_per_field_element = Math.floorDiv(P_BITWIDTH, elem_bitwidth);
    FieldElement[] compressed = (FieldElement[]) FieldElement.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{((int) Math.ceil(((double) tmp_list.length) / elems_per_field_element))}, new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"));

    for (int i = 0; i < compressed.length; i++) {
      int tmp_list_idx = i * elems_per_field_element;
      for (int j = 0, k = 0; j < elems_per_field_element && tmp_list_idx < tmp_list.length; j++, k += elem_bitwidth, tmp_list_idx++) {
        FieldElement elem = tmp_list[tmp_list_idx].copy();
        compressed[i].assign(compressed[i].add((elem.mul(FieldElement.instantiateFrom(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), BigInteger.valueOf(2).pow(k))))));
      }
    }
    return compressed;
  }
  private FieldElement[] compress(FieldElement[][] tmp_list, int elem_bitwidth) {
    if (elem_bitwidth >= P_BITWIDTH) {
      throw new IllegalArgumentException("elem_bitwidth cannot exceed p's bitwidth");
    }

    int elems_per_field_element = Math.floorDiv(P_BITWIDTH, elem_bitwidth);
    FieldElement[] compressed = (FieldElement[]) FieldElement.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{((int) Math.ceil(((double) tmp_list.length) / elems_per_field_element))}, new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"));

    for (int i = 0; i < compressed.length; i++) {
      int tmp_list_idx = i * elems_per_field_element;
      for (int j = 0, k = 0; j < elems_per_field_element && tmp_list_idx < tmp_list.length; j++, k += elem_bitwidth, tmp_list_idx++) {
        FieldElement[] elem = tmp_list[tmp_list_idx];
        FieldElement concatenated = elem[0].copy();
        concatenated.assign(concatenated.add((elem[1].mul(FieldElement.instantiateFrom(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), BigInteger.valueOf(2).pow(JUMPKIND_BITWIDTH))))));
        concatenated.assign(concatenated.add((elem[2].mul(FieldElement.instantiateFrom(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), BigInteger.valueOf(2).pow(JUMPKIND_BITWIDTH + ADDR_BITWIDTH))))));
        compressed[i].assign(compressed[i].add((concatenated.mul(FieldElement.instantiateFrom(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), BigInteger.valueOf(2).pow(k))))));
      }
    }
    return compressed;
  }
  private FieldElement[] make_multiple_of(FieldElement[] tmp_list, int factor, int extend) {
    int padded_len = (int) Math.ceil(((double) (tmp_list.length + extend)) / factor) * factor;
    FieldElement[] padded = (FieldElement[]) FieldElement.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{padded_len}, new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"));

    for (int i = 0; i < tmp_list.length; i++) {
      padded[i].assign(tmp_list[i]);
    }
    for (int i = tmp_list.length; i < padded_len; i++) {
      padded[i].assign(FieldElement.instantiateFrom(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), 0));
    }
    return padded;
  }
  private FieldElement hash(FieldElement[] padded_list) {
    // hash first chunk 
    FieldElement[] poseidon_state = (FieldElement[]) FieldElement.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{9}, new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"));
    poseidon_state[0].assign(FieldElement.instantiateFrom(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), 0));
    for (int i = 0; i < 8; i++) {
      poseidon_state[i + 1].assign(FieldElement.instantiateFrom(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), padded_list[i]));
    }
    poseidon_state = PoseidonHash.poseidon_hash_8(poseidon_state);

    // hash remaining chunks 
    int remaining_chunks = (padded_list.length / 8) - 1;
    for (int i = 0; i < remaining_chunks; i++) {
      for (int j = 0; j < 8; j++) {
        poseidon_state[j + 1].assign(FieldElement.instantiateFrom(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), padded_list[(i + 1) * 8 + j]).add(poseidon_state[j + 1]));
      }
      poseidon_state = PoseidonHash.poseidon_hash_8(poseidon_state);
    }
    return poseidon_state[2];
  }
  private FieldElement pop() {
    FieldElement data = new FieldElement(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), new BigInteger("0"));
    {
      Bit bit_b0ad = shadowStackTop.isNotEqualTo(UnsignedInteger.instantiateFrom(1, 0)).copy();
      boolean c_b0ad = CircuitGenerator.__getActiveCircuitGenerator().__checkConstantState(bit_b0ad);
      if (c_b0ad) {
        if (bit_b0ad.getConstantValue()) {
          shadowStackTop.assign(shadowStackTop.subtract(UnsignedInteger.instantiateFrom(1, 1)), 4);
          data.assign(shadowStackMem.read(shadowStackTop));
        } else {

        }
      } else {
        ConditionalScopeTracker.pushMain();
        ConditionalScopeTracker.push(bit_b0ad);
        shadowStackTop.assign(shadowStackTop.subtract(UnsignedInteger.instantiateFrom(1, 1)), 4);
        data.assign(shadowStackMem.read(shadowStackTop));

        ConditionalScopeTracker.pop();

        ConditionalScopeTracker.push(new Bit(true));

        ConditionalScopeTracker.pop();
        ConditionalScopeTracker.popMain();
      }

    }
    return data;
  }
  private void push(FieldElement data) {
    CircuitGenerator.__getActiveCircuitGenerator().__addOneAssertion(shadowStackTop.isNotEqualTo(UnsignedInteger.instantiateFrom(11, SHADOWSTACK_DEPTH)).getWire());
    shadowStackMem.write(shadowStackTop, data);
    shadowStackTop.assign(shadowStackTop.add(UnsignedInteger.instantiateFrom(1, 1)), 4);
  }

  public void __generateSampleInput(CircuitEvaluator evaluator) {
    __generateRandomInput(evaluator);
  }

}
