package xjsnark.zekra_c2;

/*Generated by MPS */

import backend.structure.CircuitGenerator;
import backend.config.Config;
import backend.eval.SampleRun;
import java.math.BigInteger;
import backend.auxTypes.FieldElement;
import util.Util;
import backend.eval.CircuitEvaluator;

public class zekra_c2 extends CircuitGenerator {



  public static void main(String[] args) {
    Config.inputVerbose = false;
    Config.outputVerbose = false;
    Config.writeCircuits = false;
    new zekra_c2();
  }

  public zekra_c2() {
    super("zekra_c2");
    __generateCircuit();
    this.__evaluateSampleRun(new SampleRun("Sample_Run1", true) {
      public void pre() {
        for (int i = 0; i < EXECUTION_PATH_SIZE; i++) {
          EXECUTION_PATH[i][0].mapValue(BigInteger.ONE, CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());
          EXECUTION_PATH[i][1].mapValue(BigInteger.ONE, CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());
          EXECUTION_PATH[i][2].mapValue(BigInteger.ONE, CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());
        }
        executionPathDigest.mapValue(BigInteger.ONE, CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());
        nonceVerifier.mapValue(BigInteger.ZERO, CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());
        noncePath.mapValue(BigInteger.ZERO, CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());
      }
      public void post() {
      }

    });

  }



  public void __init() {
    EXECUTION_PATH = (FieldElement[][]) FieldElement.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{EXECUTION_PATH_SIZE, 3}, new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"));
    executionPathDigest = new FieldElement(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), new BigInteger("0"));
    nonceVerifier = new FieldElement(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), new BigInteger("0"));
    noncePath = new FieldElement(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), new BigInteger("0"));
  }

  private FieldElement[][] EXECUTION_PATH;
  private FieldElement executionPathDigest;
  private FieldElement nonceVerifier;
  private FieldElement noncePath;

  private static int P_BITWIDTH = 254;
  private static int JUMPKIND_BITWIDTH = 2;
  private static int ADDR_BITWIDTH = 40;
  private static int EXECUTION_PATH_SIZE = 30;
  @Override
  public void __defineInputs() {
    super.__defineInputs();
    executionPathDigest = FieldElement.createInput(this, new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"));
    nonceVerifier = FieldElement.createInput(this, new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"));















  }
  @Override
  public void __defineVerifiedWitnesses() {
    super.__defineVerifiedWitnesses();

    noncePath = FieldElement.createVerifiedWitness(this, new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"));




    EXECUTION_PATH = (FieldElement[][]) FieldElement.createVerifiedWitnessArray(CircuitGenerator.__getActiveCircuitGenerator(), Util.getArrayDimensions(EXECUTION_PATH), new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"));














  }
  @Override
  public void __defineWitnesses() {
    super.__defineWitnesses();

















  }
  public void outsource() {
    // then verify authenticity of execution path 
    int transition_bitwidth = JUMPKIND_BITWIDTH + ADDR_BITWIDTH * 2;
    FieldElement[] path_compressed = compress(EXECUTION_PATH, transition_bitwidth);
    FieldElement[] path_padded = make_multiple_of(path_compressed, 8, 2);
    path_padded[path_padded.length - 2].assign(nonceVerifier);
    path_padded[path_padded.length - 1].assign(noncePath);
    FieldElement tmp_path_digest = hash(path_padded).copy();
    CircuitGenerator.__getActiveCircuitGenerator().__addDebugInstruction(tmp_path_digest, "computed path digest");
    CircuitGenerator.__getActiveCircuitGenerator().__addDebugInstruction(executionPathDigest, "input path digest");
    tmp_path_digest.forceEqual(executionPathDigest);
  }
  private FieldElement[] compress(FieldElement[][] tmp_list, int elem_bitwidth) {
    if (elem_bitwidth >= P_BITWIDTH) {
      throw new IllegalArgumentException("elem_bitwidth cannot exceed p's bitwidth");
    }

    int elems_per_field_element = Math.floorDiv(P_BITWIDTH, elem_bitwidth);
    FieldElement[] compressed = (FieldElement[]) FieldElement.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{((int) Math.ceil(((double) tmp_list.length) / elems_per_field_element))}, new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"));

    for (int i = 0; i < compressed.length; i++) {
      int tmp_list_idx = i * elems_per_field_element;
      for (int j = 0, k = 0; j < elems_per_field_element && tmp_list_idx < tmp_list.length; j++, k += elem_bitwidth, tmp_list_idx++) {
        FieldElement[] elem = tmp_list[tmp_list_idx];
        FieldElement concatenated = elem[0].copy();
        concatenated.assign(concatenated.add((elem[1].mul(FieldElement.instantiateFrom(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), BigInteger.valueOf(2).pow(JUMPKIND_BITWIDTH))))));
        concatenated.assign(concatenated.add((elem[2].mul(FieldElement.instantiateFrom(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), BigInteger.valueOf(2).pow(JUMPKIND_BITWIDTH + ADDR_BITWIDTH))))));
        compressed[i].assign(compressed[i].add((concatenated.mul(FieldElement.instantiateFrom(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), BigInteger.valueOf(2).pow(k))))));
      }
    }
    return compressed;
  }
  private FieldElement[] make_multiple_of(FieldElement[] tmp_list, int factor, int extend) {
    int padded_len = (int) Math.ceil(((double) (tmp_list.length + extend)) / factor) * factor;
    FieldElement[] padded = (FieldElement[]) FieldElement.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{padded_len}, new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"));

    for (int i = 0; i < tmp_list.length; i++) {
      padded[i].assign(tmp_list[i]);
    }
    for (int i = tmp_list.length; i < padded_len; i++) {
      padded[i].assign(FieldElement.instantiateFrom(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), 0));
    }
    return padded;
  }
  private FieldElement hash(FieldElement[] padded_list) {
    // hash first chunk 
    FieldElement[] poseidon_state = (FieldElement[]) FieldElement.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{9}, new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"));
    poseidon_state[0].assign(FieldElement.instantiateFrom(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), 0));
    for (int i = 0; i < 8; i++) {
      poseidon_state[i + 1].assign(FieldElement.instantiateFrom(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), padded_list[i]));
    }
    poseidon_state = PoseidonHash.poseidon_hash_8(poseidon_state);

    // hash remaining chunks 
    int remaining_chunks = (padded_list.length / 8) - 1;
    for (int i = 0; i < remaining_chunks; i++) {
      for (int j = 0; j < 8; j++) {
        poseidon_state[j + 1].assign(FieldElement.instantiateFrom(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), padded_list[(i + 1) * 8 + j]).add(poseidon_state[j + 1]));
      }
      poseidon_state = PoseidonHash.poseidon_hash_8(poseidon_state);
    }
    return poseidon_state[2];
  }

  public void __generateSampleInput(CircuitEvaluator evaluator) {
    __generateRandomInput(evaluator);
  }

}
