package xjsnark.zekra_c5;

/*Generated by MPS */

import backend.structure.CircuitGenerator;
import backend.config.Config;
import backend.eval.SampleRun;
import java.math.BigInteger;
import backend.auxTypes.FieldElement;
import backend.auxTypes.UnsignedInteger;
import backend.auxTypes.SmartMemory;
import util.Util;
import backend.auxTypes.Bit;
import backend.auxTypes.ConditionalScopeTracker;
import backend.eval.CircuitEvaluator;

public class zekra_c5 extends CircuitGenerator {



  public static void main(String[] args) {
    Config.inputVerbose = false;
    Config.outputVerbose = false;
    Config.writeCircuits = false;
    new zekra_c5();
  }

  public zekra_c5() {
    super("zekra_c5");
    __generateCircuit();
    this.__evaluateSampleRun(new SampleRun("Sample_Run1", true) {
      public void pre() {
        for (int i = 0; i < EXECUTION_PATH_SIZE; i++) {
          EXECUTION_PATH[i][0].mapValue(BigInteger.ONE, CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());
          EXECUTION_PATH[i][1].mapValue(BigInteger.ONE, CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());
          EXECUTION_PATH[i][2].mapValue(BigInteger.ONE, CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());
          NUMIFIED_EXECUTION_PATH[i][0].mapValue(BigInteger.ONE, CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());
          NUMIFIED_EXECUTION_PATH[i][1].mapValue(BigInteger.ONE, CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());
          dest[i].mapValue(BigInteger.ONE, CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());
          eAndR1[i][0].mapValue(BigInteger.ONE, CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());
          eAndR1[i][1].mapValue(BigInteger.ONE, CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());
          for (int j = 0; j < ADJLIST_LEVELS * 2; j++) {
            neighborEq[i][j].mapValue(BigInteger.ONE, CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());
          }
          neighborExistsProof[i][0].mapValue(BigInteger.ONE, CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());
          neighborExistsProof[i][1].mapValue(BigInteger.ONE, CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());
          neighborExistsProof[i][2].mapValue(BigInteger.ONE, CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());
          neighborExistsProof[i][3].mapValue(BigInteger.ONE, CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());
          neighborExistsProof[i][4].mapValue(BigInteger.ONE, CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());
        }
        for (int i = 0; i < ADJLIST_SIZE; i++) {
          ADJLIST[i].mapValue(BigInteger.ONE, CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());
        }
        initialNode.mapValue(BigInteger.ONE, CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());
        finalNode.mapValue(BigInteger.ONE, CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());
      }
      public void post() {
      }

    });

  }



  public void __init() {
    ADJLIST = (FieldElement[]) FieldElement.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{ADJLIST_SIZE}, new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"));
    EXECUTION_PATH = (FieldElement[][]) FieldElement.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{EXECUTION_PATH_SIZE, 3}, new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"));
    NUMIFIED_EXECUTION_PATH = (FieldElement[][]) FieldElement.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{EXECUTION_PATH_SIZE, 2}, new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"));
    initialNode = new UnsignedInteger(11, new BigInteger("0"));
    finalNode = new UnsignedInteger(11, new BigInteger("0"));
    eAndR1 = (UnsignedInteger[][]) UnsignedInteger.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{EXECUTION_PATH_SIZE, 2}, 8);
    neighborEq = (FieldElement[][]) FieldElement.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{EXECUTION_PATH_SIZE, ADJLIST_LEVELS * 2}, new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"));
    neighborExistsProof = (FieldElement[][]) FieldElement.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{EXECUTION_PATH_SIZE, 5}, new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"));
    dest = (UnsignedInteger[]) UnsignedInteger.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{EXECUTION_PATH_SIZE}, 11);
  }

  private FieldElement[] ADJLIST;
  private FieldElement[][] EXECUTION_PATH;
  private FieldElement[][] NUMIFIED_EXECUTION_PATH;
  private UnsignedInteger initialNode;
  private UnsignedInteger finalNode;
  private UnsignedInteger[][] eAndR1;
  private FieldElement[][] neighborEq;
  private FieldElement[][] neighborExistsProof;
  private UnsignedInteger[] dest;
  private SmartMemory<FieldElement> adjListMem;

  private static int BUCKET_BITWIDTH = 7;
  private static int ADJLIST_SIZE = 100;
  private static int ADJLIST_LEVELS = 10;
  private static int EXECUTION_PATH_SIZE = 30;
  @Override
  public void __defineInputs() {
    super.__defineInputs();
    initialNode = UnsignedInteger.createInput(this, 11);
    finalNode = UnsignedInteger.createInput(this, 11);















  }
  @Override
  public void __defineVerifiedWitnesses() {
    super.__defineVerifiedWitnesses();





    EXECUTION_PATH = (FieldElement[][]) FieldElement.createVerifiedWitnessArray(CircuitGenerator.__getActiveCircuitGenerator(), Util.getArrayDimensions(EXECUTION_PATH), new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"));
    ADJLIST = (FieldElement[]) FieldElement.createVerifiedWitnessArray(CircuitGenerator.__getActiveCircuitGenerator(), Util.getArrayDimensions(ADJLIST), new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"));
    neighborEq = (FieldElement[][]) FieldElement.createVerifiedWitnessArray(CircuitGenerator.__getActiveCircuitGenerator(), Util.getArrayDimensions(neighborEq), new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"));
    neighborExistsProof = (FieldElement[][]) FieldElement.createVerifiedWitnessArray(CircuitGenerator.__getActiveCircuitGenerator(), Util.getArrayDimensions(neighborExistsProof), new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"));
    NUMIFIED_EXECUTION_PATH = (FieldElement[][]) FieldElement.createVerifiedWitnessArray(CircuitGenerator.__getActiveCircuitGenerator(), Util.getArrayDimensions(NUMIFIED_EXECUTION_PATH), new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"));














  }
  @Override
  public void __defineWitnesses() {
    super.__defineWitnesses();





    eAndR1 = (UnsignedInteger[][]) UnsignedInteger.createWitnessArray(CircuitGenerator.__getActiveCircuitGenerator(), Util.getArrayDimensions(eAndR1), 8);
    dest = (UnsignedInteger[]) UnsignedInteger.createWitnessArray(CircuitGenerator.__getActiveCircuitGenerator(), Util.getArrayDimensions(dest), 11);












  }
  public void outsource() {
    adjListMem = new SmartMemory(ADJLIST, FieldElement.__getClassRef(), new Object[]{"21888242871839275222246405745257275088548364400416034343698204186575808495617"});


    // //////////////////////////// 
    // Then proceed to verify forward and back edges using the numified execution path 

    // start from the initial node 
    UnsignedInteger state = initialNode.copy(11);

    // traverse the execution path 
    for (int i = 0; i < EXECUTION_PATH_SIZE; i++) {

      // jmpkind: 00 (jmp), 01 (call), 10 (ret), 11 (empty) 
      FieldElement jmpkind = EXECUTION_PATH[i][0].copy();
      FieldElement destNode = NUMIFIED_EXECUTION_PATH[i][0].copy();

      // verify forward edges (ignore empty moves to facilitate dynamic path lengths) 
      {
        Bit bit_g0k0jb = jmpkind.isNotEqualTo(FieldElement.instantiateFrom(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), 3)).copy();
        boolean c_g0k0jb = CircuitGenerator.__getActiveCircuitGenerator().__checkConstantState(bit_g0k0jb);
        if (c_g0k0jb) {
          if (bit_g0k0jb.getConstantValue()) {

            UnsignedInteger uintDestNode = dest[i].copy(11);
            destNode.forceEqual(FieldElement.instantiateFrom(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), uintDestNode));
            UnsignedInteger bucket = uintDestNode.div(UnsignedInteger.instantiateFrom(4, 8)).copy(11);
            UnsignedInteger pos = UnsignedInteger.instantiateFrom(3, uintDestNode.mod(UnsignedInteger.instantiateFrom(4, 8))).copy(3);

            // retrieve the neighbour list of the current node 
            FieldElement currNodeNeighbors = adjListMem.read(state);

            // v.t. neighbor equation equals the current node's neighbors 
            FieldElement neighborEqProd = new FieldElement(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), new BigInteger("0"));
            for (int j = 0, k = 0; j < ADJLIST_LEVELS * 2; j += 2, k += (BUCKET_BITWIDTH + 8)) {
              neighborEqProd.assign(neighborEqProd.add(neighborEq[i][j].mul(FieldElement.instantiateFrom(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), BigInteger.valueOf(2).pow(k)))));
              neighborEqProd.assign(neighborEqProd.add(neighborEq[i][j + 1].mul(FieldElement.instantiateFrom(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), BigInteger.valueOf(2).pow(k + BUCKET_BITWIDTH)))));
            }
            neighborEqProd.forceEqual(currNodeNeighbors);

            // v.t. h * 2 + k = f 
            neighborExistsProof[i][3].mul(FieldElement.instantiateFrom(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), 2)).add(neighborExistsProof[i][4]).forceEqual(neighborExistsProof[i][1]);
            // v.t. bit at pos is set 
            neighborExistsProof[i][4].forceEqual(FieldElement.instantiateFrom(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), 1));

            // v.t. e=2**(destNode%8) 
            // efficient linear search to find if there is some j s.t. e = 2**j AND pos=j, where pos is computed inside the circuit as pos=destNode%8 
            FieldElement validExp = FieldElement.instantiateFrom(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), 1).copy();
            for (double j = 0, k = 1; j < 8; j++, k = Math.pow(2, j)) {
              validExp.assign(validExp.mul(((FieldElement.instantiateFrom(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), pos).subtract(FieldElement.instantiateFrom(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), new Double(j).intValue()))).add((neighborExistsProof[i][0].subtract(FieldElement.instantiateFrom(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), new Double(k).intValue())))))));
            }
            validExp.forceEqual(FieldElement.instantiateFrom(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), 0));

            // v.t. g < e 
            FieldElement.instantiateFrom(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), eAndR1[i][0]).forceEqual(neighborExistsProof[i][0]);
            FieldElement.instantiateFrom(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), eAndR1[i][1]).forceEqual(neighborExistsProof[i][2]);
            CircuitGenerator.__getActiveCircuitGenerator().__addOneAssertion(eAndR1[i][0].isGreaterThan(eAndR1[i][1]).getWire());

            // v.t. destNode exists at some level in the adjacency list 
            FieldElement destNodeExists = FieldElement.instantiateFrom(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), 1).copy();
            for (int j = 0; j < ADJLIST_LEVELS * 2; j += 2) {
              // v.t. f * e + g = rems 
              FieldElement remaindersMatch = neighborExistsProof[i][1].mul(neighborExistsProof[i][0]).add(neighborExistsProof[i][2]).subtract(neighborEq[i][j + 1]).copy();
              FieldElement bucketMatch = FieldElement.instantiateFrom(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), bucket).subtract(neighborEq[i][j]).copy();
              // v.t. remaindersMatch and bucketMatch 
              destNodeExists.assign(destNodeExists.mul((remaindersMatch.add(bucketMatch))));
            }
            destNodeExists.forceEqual(FieldElement.instantiateFrom(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), 0));

            // update position in the CFG 
            state.assign(uintDestNode, 11);
          } else {

          }
        } else {
          ConditionalScopeTracker.pushMain();
          ConditionalScopeTracker.push(bit_g0k0jb);

          UnsignedInteger uintDestNode = dest[i].copy(11);
          destNode.forceEqual(FieldElement.instantiateFrom(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), uintDestNode));
          UnsignedInteger bucket = uintDestNode.div(UnsignedInteger.instantiateFrom(4, 8)).copy(11);
          UnsignedInteger pos = UnsignedInteger.instantiateFrom(3, uintDestNode.mod(UnsignedInteger.instantiateFrom(4, 8))).copy(3);

          // retrieve the neighbour list of the current node 
          FieldElement currNodeNeighbors = adjListMem.read(state);

          // v.t. neighbor equation equals the current node's neighbors 
          FieldElement neighborEqProd = new FieldElement(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), new BigInteger("0"));
          for (int j = 0, k = 0; j < ADJLIST_LEVELS * 2; j += 2, k += (BUCKET_BITWIDTH + 8)) {
            neighborEqProd.assign(neighborEqProd.add(neighborEq[i][j].mul(FieldElement.instantiateFrom(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), BigInteger.valueOf(2).pow(k)))));
            neighborEqProd.assign(neighborEqProd.add(neighborEq[i][j + 1].mul(FieldElement.instantiateFrom(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), BigInteger.valueOf(2).pow(k + BUCKET_BITWIDTH)))));
          }
          neighborEqProd.forceEqual(currNodeNeighbors);

          // v.t. h * 2 + k = f 
          neighborExistsProof[i][3].mul(FieldElement.instantiateFrom(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), 2)).add(neighborExistsProof[i][4]).forceEqual(neighborExistsProof[i][1]);
          // v.t. bit at pos is set 
          neighborExistsProof[i][4].forceEqual(FieldElement.instantiateFrom(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), 1));

          // v.t. e=2**(destNode%8) 
          // efficient linear search to find if there is some j s.t. e = 2**j AND pos=j, where pos is computed inside the circuit as pos=destNode%8 
          FieldElement validExp = FieldElement.instantiateFrom(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), 1).copy();
          for (double j = 0, k = 1; j < 8; j++, k = Math.pow(2, j)) {
            validExp.assign(validExp.mul(((FieldElement.instantiateFrom(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), pos).subtract(FieldElement.instantiateFrom(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), new Double(j).intValue()))).add((neighborExistsProof[i][0].subtract(FieldElement.instantiateFrom(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), new Double(k).intValue())))))));
          }
          validExp.forceEqual(FieldElement.instantiateFrom(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), 0));

          // v.t. g < e 
          FieldElement.instantiateFrom(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), eAndR1[i][0]).forceEqual(neighborExistsProof[i][0]);
          FieldElement.instantiateFrom(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), eAndR1[i][1]).forceEqual(neighborExistsProof[i][2]);
          CircuitGenerator.__getActiveCircuitGenerator().__addOneAssertion(eAndR1[i][0].isGreaterThan(eAndR1[i][1]).getWire());

          // v.t. destNode exists at some level in the adjacency list 
          FieldElement destNodeExists = FieldElement.instantiateFrom(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), 1).copy();
          for (int j = 0; j < ADJLIST_LEVELS * 2; j += 2) {
            // v.t. f * e + g = rems 
            FieldElement remaindersMatch = neighborExistsProof[i][1].mul(neighborExistsProof[i][0]).add(neighborExistsProof[i][2]).subtract(neighborEq[i][j + 1]).copy();
            FieldElement bucketMatch = FieldElement.instantiateFrom(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), bucket).subtract(neighborEq[i][j]).copy();
            // v.t. remaindersMatch and bucketMatch 
            destNodeExists.assign(destNodeExists.mul((remaindersMatch.add(bucketMatch))));
          }
          destNodeExists.forceEqual(FieldElement.instantiateFrom(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), 0));

          // update position in the CFG 
          state.assign(uintDestNode, 11);

          ConditionalScopeTracker.pop();

          ConditionalScopeTracker.push(new Bit(true));

          ConditionalScopeTracker.pop();
          ConditionalScopeTracker.popMain();
        }

      }
    }

    state.forceEqual(finalNode);
  }

  public void __generateSampleInput(CircuitEvaluator evaluator) {
    __generateRandomInput(evaluator);
  }

}
