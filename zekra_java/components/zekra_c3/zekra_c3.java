package xjsnark.zekra_c3;

/*Generated by MPS */

import backend.structure.CircuitGenerator;
import backend.config.Config;
import backend.eval.SampleRun;
import java.math.BigInteger;
import backend.auxTypes.FieldElement;
import util.Util;
import backend.eval.CircuitEvaluator;

public class zekra_c3 extends CircuitGenerator {



  public static void main(String[] args) {
    Config.inputVerbose = false;
    Config.outputVerbose = false;
    Config.writeCircuits = false;
    new zekra_c3();
  }

  public zekra_c3() {
    super("zekra_c3");
    __generateCircuit();
    this.__evaluateSampleRun(new SampleRun("Sample_Run1", true) {
      public void pre() {
        for (int i = 0; i < ADJLIST_SIZE + 1; i++) {
          TRANSLATOR[i].mapValue(BigInteger.ONE, CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());
        }
        translatorDigest.mapValue(BigInteger.ONE, CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());
        nonceTranslator.mapValue(BigInteger.ONE, CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());
      }
      public void post() {
      }

    });

  }



  public void __init() {
    TRANSLATOR = (FieldElement[]) FieldElement.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{ADJLIST_SIZE + 1}, new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"));
    translatorDigest = new FieldElement(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), new BigInteger("0"));
    nonceTranslator = new FieldElement(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), new BigInteger("0"));
  }

  private FieldElement[] TRANSLATOR;
  private FieldElement translatorDigest;
  private FieldElement nonceTranslator;

  private static int P_BITWIDTH = 254;
  private static int ADDR_BITWIDTH = 40;
  private static int ADJLIST_SIZE = 100;
  @Override
  public void __defineInputs() {
    super.__defineInputs();
    translatorDigest = FieldElement.createInput(this, new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"));















  }
  @Override
  public void __defineVerifiedWitnesses() {
    super.__defineVerifiedWitnesses();

    nonceTranslator = FieldElement.createVerifiedWitness(this, new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"));




    TRANSLATOR = (FieldElement[]) FieldElement.createVerifiedWitnessArray(CircuitGenerator.__getActiveCircuitGenerator(), Util.getArrayDimensions(TRANSLATOR), new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"));














  }
  @Override
  public void __defineWitnesses() {
    super.__defineWitnesses();

















  }
  public void outsource() {
    // then verify authenticity of translator 
    FieldElement[] translator_compressed = compress(TRANSLATOR, ADDR_BITWIDTH);
    FieldElement[] translator_padded = make_multiple_of(translator_compressed, 8, 1);
    translator_padded[translator_padded.length - 1].assign(nonceTranslator);
    FieldElement tmp_translator_digest = hash(translator_padded).copy();
    CircuitGenerator.__getActiveCircuitGenerator().__addDebugInstruction(tmp_translator_digest, "computed translator digest");
    CircuitGenerator.__getActiveCircuitGenerator().__addDebugInstruction(translatorDigest, "input translator digest");
    tmp_translator_digest.forceEqual(translatorDigest);
  }
  private FieldElement[] compress(FieldElement[] tmp_list, int elem_bitwidth) {
    if (elem_bitwidth >= P_BITWIDTH) {
      throw new IllegalArgumentException("elem_bitwidth cannot exceed p's bitwidth");
    }

    int elems_per_field_element = Math.floorDiv(P_BITWIDTH, elem_bitwidth);
    FieldElement[] compressed = (FieldElement[]) FieldElement.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{((int) Math.ceil(((double) tmp_list.length) / elems_per_field_element))}, new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"));

    for (int i = 0; i < compressed.length; i++) {
      int tmp_list_idx = i * elems_per_field_element;
      for (int j = 0, k = 0; j < elems_per_field_element && tmp_list_idx < tmp_list.length; j++, k += elem_bitwidth, tmp_list_idx++) {
        FieldElement elem = tmp_list[tmp_list_idx].copy();
        compressed[i].assign(compressed[i].add((elem.mul(FieldElement.instantiateFrom(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), BigInteger.valueOf(2).pow(k))))));
      }
    }
    return compressed;
  }
  private FieldElement[] make_multiple_of(FieldElement[] tmp_list, int factor, int extend) {
    int padded_len = (int) Math.ceil(((double) (tmp_list.length + extend)) / factor) * factor;
    FieldElement[] padded = (FieldElement[]) FieldElement.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{padded_len}, new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"));

    for (int i = 0; i < tmp_list.length; i++) {
      padded[i].assign(tmp_list[i]);
    }
    for (int i = tmp_list.length; i < padded_len; i++) {
      padded[i].assign(FieldElement.instantiateFrom(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), 0));
    }
    return padded;
  }
  private FieldElement hash(FieldElement[] padded_list) {
    // hash first chunk 
    FieldElement[] poseidon_state = (FieldElement[]) FieldElement.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{9}, new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"));
    poseidon_state[0].assign(FieldElement.instantiateFrom(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), 0));
    for (int i = 0; i < 8; i++) {
      poseidon_state[i + 1].assign(FieldElement.instantiateFrom(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), padded_list[i]));
    }
    poseidon_state = PoseidonHash.poseidon_hash_8(poseidon_state);

    // hash remaining chunks 
    int remaining_chunks = (padded_list.length / 8) - 1;
    for (int i = 0; i < remaining_chunks; i++) {
      for (int j = 0; j < 8; j++) {
        poseidon_state[j + 1].assign(FieldElement.instantiateFrom(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), padded_list[(i + 1) * 8 + j]).add(poseidon_state[j + 1]));
      }
      poseidon_state = PoseidonHash.poseidon_hash_8(poseidon_state);
    }
    return poseidon_state[2];
  }

  public void __generateSampleInput(CircuitEvaluator evaluator) {
    __generateRandomInput(evaluator);
  }

}
